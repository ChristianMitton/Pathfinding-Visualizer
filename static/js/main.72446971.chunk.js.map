{"version":3,"sources":["algorithms/copyObjects.js","logo.svg","dataStructures/GraphNode.js","algorithms/bfs.js","dataStructures/Queue.js","algorithms/dfs.js","algorithms/aStar.js","algorithms/dijkstra.js","algorithms/mazeGeneration.js","components/Node/Node.js","components/PathFinder.js","components/App.js","serviceWorker.js","index.js"],"names":["clone","obj","copy","constructor","attr","hasOwnProperty","copy2dArrayOfObjects","array","result","row","newRow","col","copiedObj","push","modify","newObj","Object","keys","forEach","key","module","exports","GraphNode","value","this","visited","isStart","isFinish","isWall","gCost","hCost","fCost","parent","hover","isAStarStart","next","prev","topWall","rightWall","bottomWall","leftWall","weight","Infinity","Queue","require","default","copyObjects","addChildrenToQueue","grid","currentNode","queue","numRows","numCols","enqueue","bfs","mainGrid","startNode","endNode","console","log","visitedNodes","isEmpty","dequeue","items","element","shift","length","index","shouldContinueAdding","dfs","finalArray","dfsHelper","children","getChildren","child","getNeighbors","topLeftNeighbor","topNeighbor","topRightNeighbor","rightNeighbor","bottomRighNeighbor","bottomNeighbor","bottomLeftNeighbor","leftNeighbor","arrayOfNeighbors","e","calculateGCost","yDistance","Math","abs","xDistance","floor","sqrt","calculateHCost","getLowestFCostNodeFromOpenArray","open","min","minNode","inClosedArray","node","closed","i","inOpenArray","removeFromArray","splice","aStar","neighbors","currentNeighbor","dikstra","Node","props","state","onMouseDown","onMouseEnter","onMouseUp","extraClassName","className","Component","dijkstra","generateMaze","DEFAULT_START_NODE_ROW","DEFAULT_START_NODE_COL","DEFAULT_FINISH_NODE_ROW","DEFAULT_FINISH_NODE_COL","PathFinder","mouseIsPressed","clickedStart","clickedFinish","createDefaultGrid","setState","newGrid","window","location","reload","getNewGridWithWallToggled","getNewGridWithUpdatedFinishNode","getNewGridWithUpdatedStartNode","finishNode","animate","animateMaze","setTimeout","updatedGrid","count","trigger","type","onClick","visualizeBFS","visualizeDFS","visualizeAStar","visualizeDijkstra","clear","stopAlgorithm","map","rowIdx","nodeIdx","handleMouseDown","handleMouseEnter","handleMouseUp","currentRow","newNode","oldRow","oldCol","oldStartNode","newStartNode","oldStartNodeCopy","newStartNodeCopy","oldFinishNode","newFinishNode","App","isLocalhost","Boolean","hostname","match","registerValidSW","swUrl","config","navigator","serviceWorker","register","then","registration","onupdatefound","installingWorker","installing","onstatechange","controller","onUpdate","onSuccess","catch","error","ReactDOM","render","document","getElementById","URL","process","href","origin","addEventListener","fetch","headers","response","contentType","get","status","indexOf","ready","unregister","checkValidServiceWorker"],"mappings":"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","file":"static/js/main.72446971.chunk.js","sourcesContent":["function clone(obj) {\n    if (null == obj || \"object\" != typeof obj) return obj;\n    let copy = new obj.constructor();\n    for (let attr in obj) {\n        if (obj.hasOwnProperty(attr)) copy[attr] = obj[attr];\n    }\n    return copy;\n}\n\nfunction copy2dArrayOfObjects(array){\n    let result = []\n    for(let row in array){\n        let newRow = []\n        for(let col in array[row]){\n            let copiedObj = clone(array[row][col]);\n            newRow.push(copiedObj);\n        }\n        result.push(newRow);\n    }\n\n    return result;\n}\n\nfunction modify(obj, newObj) {\n\n    Object.keys(obj).forEach(function(key) {\n      delete obj[key];\n    });\n  \n    Object.keys(newObj).forEach(function(key) {\n      obj[key] = newObj[key];\n    });\n    \n  }\n\n\n// module.exports.copy2dArrayOfObjects = copy2dArrayOfObjects;\n// module.exports.clone = clone;\n// module.exports.modify = modify;\n\n// export {\n//   copy2dArrayOfObjects,\n//   modify,\n//   clone\n// }\n\nexport default {copy2dArrayOfObjects, modify, clone}","module.exports = __webpack_public_path__ + \"static/media/logo.5d5d9eef.svg\";","class GraphNode {\n    constructor(value, row, col){\n        this.value = value;\n        this.row = row;\n        this.col = col; \n        this.visited = false;\n        this.isStart = false;\n        this.isFinish = false;\n        this.isWall = false;\n        this.gCost = 0;\n        this.hCost = 0;\n        this.fCost = 0;\n        this.parent = null;\n        this.hover = false;\n        this.isAStarStart = false;        \n        this.next = null;    \n        this.prev = null;\n        this.topWall = false;\n        this.rightWall = false;\n        this.bottomWall = false;\n        this.leftWall = false;\n        this.weight = Infinity;            \n    }\n}\n\nexport default GraphNode;","let Queue = require('../dataStructures/Queue').default;\n//let addChildrenToQueue = require('./addChildrenToQueue')\nlet copyObjects = require('./copyObjects').default;\n\nfunction bfs(mainGrid, startNode, endNode, numRows, numCols){    \n    console.log(`Start Node: row:${startNode.row} col:${startNode.col}`);\n    console.log(`End Node: row:${endNode.row} col:${endNode.col}`);\n    console.log();\n    let queue = new Queue();\n\n    //console.log(`Here is the main grid after splicing: ${mainGrid}`);\n    //let grid = [...mainGrid];\n    let grid = copyObjects.copy2dArrayOfObjects(mainGrid);\n    \n    //console.log(`Here is the temp grid after splicing: ${grid}`);\n\n    let visitedNodes = [];    \n    \n    grid[startNode.row][startNode.col].visited = true;\n\n    queue.enqueue(startNode);   \n\n    while(!queue.isEmpty()){\n        let currentNode = queue.dequeue();        \n        // append current node to visited array\n        visitedNodes.push(currentNode);\n\n        let {row, col} = currentNode;        \n\n        //console.log(`currentNode: <node>(${row},${col})`);\n\n        if(row === endNode.row && col === endNode.col){            \n            console.log(\"Reached destination\");\n            return visitedNodes;\n        }\n        \n        addChildrenToQueue(grid, currentNode, queue, numRows, numCols); \n\n        //process.stdout.write(\"Queue contents after adding children:\");\n        //queue.printGraphQueue();\n    }\n\n    console.log(\"Did not reach destination\");\n    return visitedNodes;\n}\n\nfunction addChildrenToQueue(grid, currentNode, queue, numRows, numCols){    \n            \n        // console.log(\"...\")\n        // console.log(`About to assign ${currentNode}, ${currentNode}`)\n\n        let {row, col} = currentNode;    \n\n        // console.log(`Here is the row, col ${row}, ${col}`)\n\n\n    /*\n    ?   ---------------------------------------------------\n    ?   |               Corner edge cases                 |\n    ?   ---------------------------------------------------\n    */\n    //! top left corner\n    if(row === 0 && col === 0) {            \n        //right child\n        if(!grid[row][col+1].visited){\n            grid[row][col+1].visited = true;\n            queue.enqueue(grid[row][col+1])\n        }\n\n        //bottom child\n        if(!grid[row+1][col].visited){\n            grid[row+1][col].visited = true;\n            queue.enqueue(grid[row+1][col])    \n        }\n        return;             \n    }\n    //! top right corner\n    else if(row === 0 && col === (numCols-1)){\n        //bottom child\n        if(!grid[row+1][col].visited){\n            grid[row+1][col].visited = true;\n            queue.enqueue(grid[row+1][col]) \n        }        \n\n        //left child\n        if(!grid[row][col-1].visited){\n            grid[row][col-1].visited = true;\n            queue.enqueue(grid[row][col-1]) \n        }        \n        return;\n    }\n    //! bottom right corner\n    else if(row === (numRows-1) && col === (numCols-1)){\n        //top child\n        if(!grid[row-1][col].visited){\n            grid[row-1][col].visited = true;\n            queue.enqueue(grid[row-1][col]) \n        }        \n\n        //left child\n        if(!grid[row][col-1].visited){\n            grid[row][col-1].visited = true;\n            queue.enqueue(grid[row][col-1]) \n        }        \n        return;\n    }\n    //! bottom left corner\n    else if(row === (numRows-1) && col === 0){\n        //top child\n        if(!grid[row-1][col].visited){\n            grid[row-1][col].visited = true;\n            queue.enqueue(grid[row-1][col]) \n        }        \n\n        //right child\n        if(!grid[row][col+1].visited){\n            grid[row][col+1].visited = true;\n            queue.enqueue(grid[row][col+1]) \n        }        \n        return;\n    }\n    /*\n    ?   ---------------------------------------------------\n    ?   |               Border edge cases                 |\n    ?   ---------------------------------------------------\n    */\n    //! top border\n    else if(row === 0){\n        //right child\n        if(!grid[row][col+1].visited){\n            grid[row][col+1].visited = true;\n            queue.enqueue(grid[row][col+1]) \n        }        \n\n        //bottom child\n        if(!grid[row+1][col].visited){\n            grid[row+1][col].visited = true;\n            queue.enqueue(grid[row+1][col]) \n        }\n        \n        //left child  \n        if(!grid[row][col-1].visited){\n            grid[row][col-1].visited = true;\n            queue.enqueue(grid[row][col-1])            \n        }        \n        return;\n    }\n    //! right border\n    else if(col === numCols-1){\n        //top child\n        if(!grid[row-1][col].visited){\n            grid[row-1][col].visited = true;\n            queue.enqueue(grid[row-1][col]) \n        }\n        //bottom child\n        if(!grid[row+1][col].visited){\n            grid[row+1][col].visited = true;\n            queue.enqueue(grid[row+1][col]) \n        }\n        \n        //left child\n        if(!grid[row][col-1].visited){\n            grid[row][col-1].visited = true;\n            queue.enqueue(grid[row][col-1])            \n        }        \n        \n        return;\n    }\n    //! bottom border\n    else if(row === numRows-1){\n        //top child\n        if(!grid[row-1][col].visited){\n            grid[row-1][col].visited = true;\n            queue.enqueue(grid[row-1][col]) \n        }\n        \n        //right child\n        if(!grid[row][col+1].visited){\n            grid[row][col+1].visited = true;\n            queue.enqueue(grid[row][col+1]) \n        }\n        //left child\n        if(!grid[row][col-1].visited){\n            grid[row][col-1].visited = true;\n            queue.enqueue(grid[row][col-1])            \n        }     \n        \n        return;\n    }\n    //! left border\n    else if(col === 0){\n        //top child\n        if(!grid[row-1][col].visited){\n            grid[row-1][col].visited = true;\n            queue.enqueue(grid[row-1][col]) \n        }\n        \n        //right child\n        if(!grid[row][col+1].visited){\n            grid[row][col+1].visited = true;\n            queue.enqueue(grid[row][col+1]) \n        } \n        \n        //bottom child\n        if(!grid[row+1][col].visited){\n            grid[row+1][col].visited = true;\n            queue.enqueue(grid[row+1][col]) \n        } \n        return;\n    } \n    /*\n    ?   ---------------------------------------------------\n    ?   |          General Node with 8 children           | \n    ?   ---------------------------------------------------\n    */\n    else {\n        //top child\n        if(!grid[row-1][col].visited && !grid[row-1][col].isWall){\n            grid[row-1][col].visited = true;\n            queue.enqueue(grid[row-1][col]) \n        }                \n\n        //right child\n        if(!grid[row][col+1].visited && !grid[row][col+1].isWall){\n            grid[row][col+1].visited = true;\n            queue.enqueue(grid[row][col+1]) \n        }         \n\n        //bottom child\n        if(!grid[row+1][col].visited && !grid[row+1][col].isWall){\n            grid[row+1][col].visited = true;\n            queue.enqueue(grid[row+1][col]) \n        }         \n\n        //left child\n        if(!grid[row][col-1].visited && !grid[row][col-1].isWall){\n            grid[row][col-1].visited = true;\n            queue.enqueue(grid[row][col-1])            \n        }\n    }   \n\nreturn;\n}\n\n\n//export default bfs;\nexport default bfs;","class Queue {\n    constructor(){\n        this.items = [];\n    }\n\n    enqueue(element){\n        this.items.push(element);\n    }\n\n    dequeue(element){\n        if(this.isEmpty()){\n            console.log(\"Empty queue\");\n            return;\n        }\n        return this.items.shift();\n    }\n\n    isEmpty(){\n        if(this.items.length === 0){\n            return true;\n        }\n        return false;\n    }\n\n    printQueue(){\n        for(let index in this.items){\n            console.log(this.items[index]);\n        }\n    }\n\n    printGraphQueue(){\n        console.log();\n        //process.stdout.write(\"[ \");\n        for(let index in this.items){\n            console.log(`(${this.items[index].row},${this.items[index].col}), `);\n            //process.stdout.write(`(${this.items[index].row},${this.items[index].col}), `);\n        }\n        console.log(\"]\");\n    }\n}\n\n// module.exports = Queue;\nexport default Queue;","// let GraphNode = require('../dataStructures/GraphNode');\n// let Queue = require('../dataStructures/Queue');\n//let addChildrenToQueue = require('./addChildrenToQueue');\nlet copyObjects = require('./copyObjects').default;\n\nlet shouldContinueAdding = true\n\nfunction dfs(mainGrid, startNode, endNode, numRows, numCols){\n    let grid = copyObjects.copy2dArrayOfObjects(mainGrid);   \n\n    let finalArray = []\n    \n    dfsHelper(grid, startNode, endNode, numRows, numCols, finalArray);\n\n    console.log(\"Here\")\n    console.log(`Sending ${finalArray} back`)\n    return finalArray;\n}\n\nfunction dfsHelper(grid, startNode, endNode, numRows, numCols, finalArray){\n    \n    if(startNode.row === endNode.row && startNode.col === endNode.col){                    \n        console.log(`Reached destination at ${startNode.row},${startNode.col} sending this array back ${finalArray}`)\n        shouldContinueAdding = false\n        return;\n    } \n\n    let children = getChildren(grid, startNode, numRows, numCols)    \n\n    for(let index in children){\n        //do something with element\n        let child = children[index]\n        if(shouldContinueAdding){\n            finalArray.push(child)\n        }\n\n        dfsHelper(grid, child, endNode, numRows, numCols, finalArray);\n    }\n\n    return finalArray\n}\n\n\nfunction getChildren(grid, currentNode, numRows, numCols){  \n\n    let {row, col} = currentNode;    \n\n    let result = []\n\n    /*\n    ?   ---------------------------------------------------\n    ?   |               Corner edge cases                 |\n    ?   ---------------------------------------------------\n    */\n    //! top left corner\n    if(row === 0 && col === 0) {            \n        //right child\n        if(!grid[row][col+1].visited && !grid[row][col+1].isWall && !grid[row][col+1].isWall){\n            grid[row][col+1].visited = true;\n            result.push(grid[row][col+1])\n        }\n\n        //bottom child\n        if(!grid[row+1][col].visited && !grid[row+1][col].isWall){\n            grid[row+1][col].visited = true;\n            result.push(grid[row+1][col])    \n        }\n        return result;\n    }\n    //! top right corner\n    else if(row === 0 && col === (numCols-1)){\n        //bottom child\n        if(!grid[row+1][col].visited && !grid[row+1][col].isWall){\n            grid[row+1][col].visited = true;\n            result.push(grid[row+1][col]) \n        }        \n\n        //left child\n        if(!grid[row][col-1].visited && !grid[row][col-1].isWall){\n            grid[row][col-1].visited = true;\n            result.push(grid[row][col-1]) \n        }        \n        return result;\n    }\n    //! bottom right corner\n    else if(row === (numRows-1) && col === (numCols-1)){\n        //top child\n        if(!grid[row-1][col].visited && !grid[row-1][col].isWall){\n            grid[row-1][col].visited = true;\n            result.push(grid[row-1][col]) \n        }        \n\n        //left child\n        if(!grid[row][col-1].visited && !grid[row][col-1].isWall){\n            grid[row][col-1].visited = true;\n            result.push(grid[row][col-1]) \n        }        \n        return result;\n    }\n    //! bottom left corner\n    else if(row === (numRows-1) && col === 0){\n        //top child\n        if(!grid[row-1][col].visited && !grid[row-1][col].isWall){\n            grid[row-1][col].visited = true;\n            result.push(grid[row-1][col]) \n        }        \n\n        //right child\n        if(!grid[row][col+1].visited && !grid[row][col+1].isWall){\n            grid[row][col+1].visited = true;\n            result.push(grid[row][col+1]) \n        }        \n        return result;\n    }\n    /*\n    ?   ---------------------------------------------------\n    ?   |               Border edge cases                 |\n    ?   ---------------------------------------------------\n    */\n    //! top border\n    else if(row === 0){\n        //right child\n        if(!grid[row][col+1].visited && !grid[row][col+1].isWall){\n            grid[row][col+1].visited = true;\n            result.push(grid[row][col+1]) \n        }        \n\n        //bottom child\n        if(!grid[row+1][col].visited && !grid[row+1][col].isWall){\n            grid[row+1][col].visited = true;\n            result.push(grid[row+1][col]) \n        }\n        \n        //left child  \n        if(!grid[row][col-1].visited && !grid[row][col-1].isWall){\n            grid[row][col-1].visited = true;\n            result.push(grid[row][col-1])            \n        }        \n        return result;\n    }\n    //! right border\n    else if(col === numCols-1){\n        //top child\n        if(!grid[row-1][col].visited && !grid[row-1][col].isWall){\n            grid[row-1][col].visited = true;\n            result.push(grid[row-1][col]) \n        }\n        //bottom child\n        if(!grid[row+1][col].visited && !grid[row+1][col].isWall){\n            grid[row+1][col].visited = true;\n            result.push(grid[row+1][col]) \n        }\n        \n        //left child\n        if(!grid[row][col-1].visited && !grid[row][col-1].isWall){\n            grid[row][col-1].visited = true;\n            result.push(grid[row][col-1])            \n        }        \n        \n        return result;\n    }\n    //! bottom border\n    else if(row === numRows-1){\n        //top child\n        if(!grid[row-1][col].visited && !grid[row-1][col].isWall){\n            grid[row-1][col].visited = true;\n            result.push(grid[row-1][col]) \n        }\n        \n        //right child\n        if(!grid[row][col+1].visited && !grid[row][col+1].isWall){\n            grid[row][col+1].visited = true;\n            result.push(grid[row][col+1]) \n        }\n        //left child\n        if(!grid[row][col-1].visited && !grid[row][col-1].isWall){\n            grid[row][col-1].visited = true;\n            result.push(grid[row][col-1])            \n        }     \n        \n        return result;\n    }\n    //! left border\n    else if(col === 0){\n        //top child\n        if(!grid[row-1][col].visited && !grid[row-1][col].isWall){\n            grid[row-1][col].visited = true;\n            result.push(grid[row-1][col]) \n        }\n        \n        //right child\n        if(!grid[row][col+1].visited && !grid[row][col+1].isWall){\n            grid[row][col+1].visited = true;\n            result.push(grid[row][col+1]) \n        } \n        \n        //bottom child\n        if(!grid[row+1][col].visited && !grid[row+1][col].isWall){\n            grid[row+1][col].visited = true;\n            result.push(grid[row+1][col]) \n        } \n        return result;\n    } \n    /*\n    ?   ---------------------------------------------------\n    ?   |          General Node with 8 children           | \n    ?   ---------------------------------------------------\n    */\n    else {\n        //top child\n        if(!grid[row-1][col].visited && !grid[row-1][col].isWall){\n            grid[row-1][col].visited = true;\n            result.push(grid[row-1][col]) \n        }                \n\n        //right child\n        if(!grid[row][col+1].visited && !grid[row][col+1].isWall){\n            grid[row][col+1].visited = true;\n            result.push(grid[row][col+1]) \n        }         \n\n        //bottom child\n        if(!grid[row+1][col].visited && !grid[row+1][col].isWall){\n            grid[row+1][col].visited = true;\n            result.push(grid[row+1][col]) \n        }         \n\n        //left child\n        if(!grid[row][col-1].visited && !grid[row][col-1].isWall){\n            grid[row][col-1].visited = true;\n            result.push(grid[row][col-1])            \n        }\n    }   \n\n    return result;\n}\n\nexport default dfs;","let copyObjects = require('./copyObjects').default;\n\nfunction aStar(mainGrid, startNode, endNode, numRows, numCols){\n    \n    let grid = copyObjects.copy2dArrayOfObjects(mainGrid);\n\n    let finalArray = []\n\n    startNode.isAStarStart = true;\n    \n    //* 1.)\n    let open = []\n    //* 2.)\n    let closed = []\n    \n    open.push(startNode)\n    \n    while(open.length > 0){\n        //get node with lowest f cost\n        let currentNode = getLowestFCostNodeFromOpenArray(open)        \n        // console.log(1)\n        \n        if(currentNode.isAStarStart === true){\n            // console.log(`At start node ${currentNode.row}, ${currentNode.col}`)    \n        } else {\n            //console.log(`currentNode: ${currentNode.row},${currentNode.col} [G: ${currentNode.gCost}, H:${currentNode.hCost}, F:${currentNode.fCost}] parent: (${currentNode.parent.row}, ${currentNode.parent.col})`)\n            // console.log(`Choosing node With lowest f Cost: ${currentNode.row},${currentNode.col} [G: ${currentNode.gCost}, H:${currentNode.hCost}, F:${currentNode.fCost}] parent: (${currentNode.parent.row}, ${currentNode.parent.col})`)\n        }\n\n        // finalArray.push(currentNode)\n        \n        if(currentNode.parent != null){ //---------------->\n        //if(currentNode != null){\n            //finalArray.push(currentNode.parent)            \n        }        \n\n        removeFromArray(currentNode, open)        \n\n        if(currentNode.row === endNode.row && currentNode.col === endNode.col){            \n            // console.log(\"Reached Destination\")\n            return finalArray\n        }\n        \n        if(inClosedArray(currentNode, closed) || currentNode.isWall){\n            continue\n        }        \n\n        let neighbors = getNeighbors(currentNode, grid)        \n\n        for(let index in neighbors){            \n            let currentNeighbor = neighbors[index]\n\n            if(currentNeighbor.isWall){\n                continue\n            }\n\n            // if at destination\n            if(currentNeighbor.row === endNode.row && currentNeighbor.col === endNode.col){            \n                // console.log(\"Reached Destination\")\n                return finalArray\n            }\n\n            // recently added\n            // if(currentNeighbor.isAStarStart === true){\n            //     continue\n            // }            \n\n            if(!inOpenArray(currentNeighbor, open) || currentNeighbor.parent == null || currentNeighbor.parent.fCost < currentNode.fCost/* new path to currentNeighbor is shorter */){                  \n                currentNeighbor.gCost = calculateGCost(currentNeighbor, startNode)\n                currentNeighbor.hCost = calculateHCost(currentNeighbor, endNode)\n                currentNeighbor.fCost = currentNeighbor.hCost\n                \n                currentNeighbor.parent = currentNode\n\n                // console.log(`---- neighbor ${currentNeighbor.row},${currentNeighbor.col} [g: ${currentNeighbor.gCost} h: ${currentNeighbor.hCost} f: ${currentNeighbor.fCost}]`)\n\n                // currentNode.parent = currentNeighbor\n\n                // NEW\n                finalArray.push(currentNeighbor)                \n\n                if(!inOpenArray(currentNeighbor, open)){\n                    open.push(currentNeighbor)\n                }\n            }            \n        }\n        closed.push(currentNode)        \n        \n    }\n\n    // console.log('did not reach destination')\n}\n\nfunction getNeighbors(currentNode, grid){\n    let {row, col} = currentNode\n\n    //the column of the start node detemines the currentNodes gCost\n    // Math.abs(col*sqrt(2) - startNode.col*sqrt(2))\n    \n    try{\n        let topLeftNeighbor = grid[row-1][col-1]\n        let topNeighbor = grid[row-1][col]\n        let topRightNeighbor = grid[row-1][col+1]\n        let rightNeighbor = grid[row][col+1]\n        let bottomRighNeighbor = grid[row+1][col+1]\n        let bottomNeighbor = grid[row+1][col]\n        let bottomLeftNeighbor = grid[row+1][col-1]\n        let leftNeighbor = grid[row][col-1]  \n\n        let arrayOfNeighbors = []\n\n        arrayOfNeighbors.push(topLeftNeighbor)\n        arrayOfNeighbors.push(topNeighbor)\n        arrayOfNeighbors.push(topRightNeighbor)\n        arrayOfNeighbors.push(rightNeighbor)\n        arrayOfNeighbors.push(bottomRighNeighbor)\n        arrayOfNeighbors.push(bottomNeighbor)\n        arrayOfNeighbors.push(bottomLeftNeighbor)\n        arrayOfNeighbors.push(leftNeighbor)\n\n        return arrayOfNeighbors\n    } catch(e){\n        \n    }\n\n}\n\n// G Cost = distance from starting node \n// // TODO: Sometimes you want to update the g cost, sometimes you don't\nfunction calculateGCost(currentNode, startNode){\n    let {row, col} = currentNode\n\n    let yDistance = Math.abs(col - startNode.col)\n    let xDistance = Math.abs(row - startNode.row)\n\n    let gCost = Math.floor(Math.sqrt((xDistance + yDistance) * 10))\n    \n    return gCost\n}\n\n// ! H cost = distance from end node\nfunction calculateHCost(currentNode, endNode){    \n    let {row, col} = currentNode    \n    //Euclidean Distance\n    // let value = Math.floor(Math.sqrt(Math.abs((row-endNode.row)*2 + (col-endNode.col)*2)))\n    // return value\n    \n    //Diagonal Distance\n    // let value = Math.max(Math.abs(row+endNode.row), Math.abs(col+endNode.col))\n    // return value\n\n    //Manhattan Distance\n    let v1 = Math.abs(endNode.row - row)\n    let v2 = Math.abs(endNode.col - col)\n    return v1 + v2\n}\n\n// ! F cost = G cost + H cost\nfunction updateFCost(currentNode){\n    currentNode.fCost = currentNode.gCost + currentNode.hCost\n    return\n}\n\n// // TODO: May need to modify this so that the open array is being searched\nfunction getLowestFCostNodeFromOpenArray(open){\n    let min = Infinity\n    let minNode = null    \n\n    open.forEach(currentNode => {                \n        if(currentNode.fCost < min){\n            min = currentNode.fCost            \n            minNode = currentNode\n        }\n    })\n    \n    return minNode\n}\n\nfunction inClosedArray(node, closed){\n\n    let {row, col} = node    \n\n    for(let i = 0; i < closed.length; i++){    \n        //console.log(\"-\")\n        let currentNode = closed[i]\n        if(row === currentNode.row && col === currentNode.col){\n            return true\n        }\n    }\n\n    return false\n}\n\nfunction inOpenArray(node, open){\n\n    let {row, col} = node    \n\n    for(let index in open){\n        let currentNode = open[index]\n        if(row === currentNode.row && col === currentNode.col){\n            return true\n        }\n    }\n\n    return false\n}\n\nfunction removeFromArray(node, array){\n\n    let {row, col} = node\n\n    for(let index in array){\n       let currentNode = array[index]\n\n       if(currentNode.row === row && currentNode.col === col){\n            array.splice(index, 1);\n       }\n   } \n}\n\nexport default aStar;\n// module.exports = aStar;\n\n\n\n/*\n * Euclidean Distance Heuristic:\n * h = sqrt ( (current_cell.x – goal.x)2 + (current_cell.y – goal.y)2 ) \n\n! Cost = distance from starting node \n    ? -top left corner\n\n! H cost = distance from end node\n    ? -top right corner    \n\n! F cost = G cost + H cost\n    ? - center\n\n*/\n\n/**\n     *  currentNode = A -> topLeft\n     * \n     *  open = [48, 62, 62, 70, 62, 62, 48, 48, 62, 48, 48, 62, 48]\n     *  closed = [A, A->42, A->42->42]\n     *      \n     * \n     *  neighbors = [ A, ]\n     *                |\n     *  currentNeighbor = 42\n     * \n     */","let copyObjects = require('./copyObjects').default;\n\nfunction dikstra(mainGrid, startNode, endNode, numRows, numCols){\n    \n    let grid = copyObjects.copy2dArrayOfObjects(mainGrid);\n\n    let finalArray = []\n\n    // startNode.isAStarStart = true;\n    \n    //* 1.)\n    let open = []\n    //* 2.)\n    let closed = []\n    \n    open.push(startNode)\n    \n    while(open.length > 0){\n        //get node with lowest f cost\n        let currentNode = getLowestFCostNodeFromOpenArray(open)        \n        // console.log(1)            \n\n        // finalArray.push(currentNode)\n        \n        if(currentNode.parent != null){ //---------------->\n        //if(currentNode != null){\n            //finalArray.push(currentNode.parent)            \n        }        \n\n        removeFromArray(currentNode, open)        \n\n        if(currentNode.row === endNode.row && currentNode.col === endNode.col){            \n            // console.log(\"Reached Destination\")\n            return finalArray\n        }\n        \n        if(inClosedArray(currentNode, closed) || currentNode.isWall){\n            continue\n        }        \n\n        let neighbors = getNeighbors(currentNode, grid, numRows, numCols)        \n\n        for(let index in neighbors){            \n            let currentNeighbor = neighbors[index]\n\n            if(currentNeighbor.isWall){\n                continue\n            }\n\n            // if at destination\n            if(currentNeighbor.row === endNode.row && currentNeighbor.col === endNode.col){            \n                console.log(\"Reached Destination\")\n                return finalArray\n            }\n\n            // recently added\n            if(currentNeighbor.isStart === true){\n                continue\n            }            \n\n            if(!inOpenArray(currentNeighbor, open) || currentNeighbor.parent == null || currentNeighbor.parent.fCost < currentNode.fCost/* new path to currentNeighbor is shorter */){                  \n                currentNeighbor.gCost = calculateGCost(currentNeighbor, startNode)\n                currentNeighbor.hCost = calculateHCost(currentNeighbor, endNode)\n                currentNeighbor.fCost = currentNeighbor.hCost\n                \n                currentNeighbor.parent = currentNode\n\n                // console.log(`---- neighbor ${currentNeighbor.row},${currentNeighbor.col} [g: ${currentNeighbor.gCost} h: ${currentNeighbor.hCost} f: ${currentNeighbor.fCost}]`)\n\n                // currentNode.parent = currentNeighbor\n\n                // NEW\n                finalArray.push(currentNeighbor)                \n\n                if(!inOpenArray(currentNeighbor, open)){\n                    open.push(currentNeighbor)\n                }\n            }            \n        }\n        closed.push(currentNode)        \n        \n    }\n\n    console.log('did not reach destination')\n}\n\nfunction getNeighbors(currentNode, grid){\n    let {row, col} = currentNode\n\n    //the column of the start node detemines the currentNodes gCost\n    // Math.abs(col*sqrt(2) - startNode.col*sqrt(2))\n    \n    try{\n    let topLeftNeighbor = grid[row-1][col-1]\n    let topNeighbor = grid[row-1][col]\n    let topRightNeighbor = grid[row-1][col+1]\n    let rightNeighbor = grid[row][col+1]\n    let bottomRighNeighbor = grid[row+1][col+1]\n    let bottomNeighbor = grid[row+1][col]\n    let bottomLeftNeighbor = grid[row+1][col-1]\n    let leftNeighbor = grid[row][col-1]  \n\n    let arrayOfNeighbors = []\n\n    arrayOfNeighbors.push(topLeftNeighbor)\n    arrayOfNeighbors.push(topNeighbor)\n    arrayOfNeighbors.push(topRightNeighbor)\n    arrayOfNeighbors.push(rightNeighbor)\n    arrayOfNeighbors.push(bottomRighNeighbor)\n    arrayOfNeighbors.push(bottomNeighbor)\n    arrayOfNeighbors.push(bottomLeftNeighbor)\n    arrayOfNeighbors.push(leftNeighbor)\n\n\n    return arrayOfNeighbors\n    } catch(e){\n\n    }\n\n    \n\n}\n\n// G Cost = distance from starting node \n// // TODO: Sometimes you want to update the g cost, sometimes you don't\nfunction calculateGCost(currentNode, startNode){\n    let {row, col} = currentNode\n\n    let yDistance = Math.abs(col - startNode.col)\n    let xDistance = Math.abs(row - startNode.row)\n\n    let gCost = Math.floor(Math.sqrt((xDistance + yDistance) * 10))\n    \n    return gCost\n}\n\n// ! H cost = distance from end node\nfunction calculateHCost(currentNode, endNode){    \n    let {row, col} = currentNode    \n    //Euclidean Distance\n    // let value = Math.floor(Math.sqrt(Math.abs((row-endNode.row)*2 + (col-endNode.col)*2)))\n    // return value\n    \n    //Diagonal Distance\n    // let value = Math.max(Math.abs(row+endNode.row), Math.abs(col+endNode.col))\n    // return value\n\n    //Manhattan Distance\n    // let v1 = Math.abs(endNode.row - row)\n    // let v2 = Math.abs(endNode.col - col)\n    // return v1 + v2\n\n    return 0\n}\n\n// ! F cost = G cost + H cost\nfunction updateFCost(currentNode){\n    currentNode.fCost = currentNode.gCost + currentNode.hCost\n    return\n}\n\n// // TODO: May need to modify this so that the open array is being searched\nfunction getLowestFCostNodeFromOpenArray(open){\n    let min = Infinity\n    let minNode = null    \n\n    open.forEach(currentNode => {                \n        if(currentNode.fCost < min){\n            min = currentNode.fCost            \n            minNode = currentNode\n        }\n    })\n    \n    return minNode\n}\n\nfunction inClosedArray(node, closed){\n\n    let {row, col} = node    \n\n    for(let i = 0; i < closed.length; i++){    \n        //console.log(\"-\")\n        let currentNode = closed[i]\n        if(row === currentNode.row && col === currentNode.col){\n            return true\n        }\n    }\n\n    return false\n}\n\nfunction inOpenArray(node, open){\n\n    let {row, col} = node    \n\n    for(let index in open){\n        let currentNode = open[index]\n        if(row === currentNode.row && col === currentNode.col){\n            return true\n        }\n    }\n\n    return false\n}\n\nfunction removeFromArray(node, array){\n\n    let {row, col} = node\n\n    for(let index in array){\n       let currentNode = array[index]\n\n       if(currentNode.row === row && currentNode.col === col){\n            array.splice(index, 1);\n       }\n   } \n}\n\nexport default dikstra;","let copyObjects = require('./copyObjects').default;\n\n//Pick random number between 1 and 4: Math.floor(Math.random()*4)\n\nfunction generateMaze(mainGrid, numRows, numCols){\n    let grid = copyObjects.copy2dArrayOfObjects(mainGrid);\n    let result = []\n\n    createChamber(grid, result, numRows, numCols)\n\n    let topLeftNode = grid[0][0]\n    let topRightNode = grid[numRows-1][numCols-1]\n    let bottomRightNode = grid[numRows-1][numCols-1]\n    let bottomLeftNode = grid[numRows-1][0]\n    \n    generateMazeRec(grid, topLeftNode, topRightNode, bottomRightNode, bottomLeftNode, result);\n    \n    console.log('done')\n    return result\n\n}\n\nfunction generateMazeRec(grid, topLeftNode, topRightNode, bottomRightNode, bottomLeftNode, result){    \n\n    let numRows = bottomRightNode.row-1\n    let numCols = bottomRightNode.col-1    \n\n    let width = bottomRightNode.col - topLeftNode.col\n    let height = bottomRightNode.row - topLeftNode.row\n\n    console.log(\"Width \" + width)\n    console.log(\"Height \" + height)\n\n    if(width < 2 && height < 2){\n        return\n    }\n\n    let orientation = chooseOrientation(width, height)\n\n    if(orientation === 'HORIZONTAL'){\n        let newCorners = bisectHorizontally(grid, topLeftNode, bottomRightNode, numRows, numCols, result)          \n        let newTopLeftNode = newCorners[0]\n        let newTopRightNode = newCorners[1]        \n        let newBottomRightNode = newCorners[2]\n        let newBottomLeftNode = newCorners[3]\n\n        console.log(`new corners H: topLeft: (${newTopLeftNode.row}, ${newTopLeftNode.col}) topRight: (${newTopRightNode.row}, ${newTopRightNode.col})`)\n        console.log(`new corners H: bottomRight: (${newBottomRightNode.row}, ${newBottomRightNode.col}) bottomLeft: (${newBottomLeftNode.row}, ${newBottomLeftNode.col})`)\n\n        //! ------------------------------------------------\n        //! NOTE maybe calculate new top nodes for top and bottom for horizontal bar, and new top nodes for both left and right side of bar for vertical\n        //! ------------------------------------------------\n\n        //recurse above\n        // generateMazeRec(grid, newTopLeftNode, newTopRightNode, topRightNode, topLeftNode, result)        \n\n        //recurse below                \n        generateMazeRec(grid, newTopLeftNode, topRightNode, newBottomRightNode, bottomLeftNode, result)        \n\n    } else if(orientation === 'VERTICAL'){\n        let newCorners = bisectVertically(grid, topLeftNode, bottomRightNode, numRows, numCols, result)                  \n        let newTopLeftNode = newCorners[0]\n        let newTopRightNode = newCorners[1]        \n        let newBottomRightNode = newCorners[2]\n        let newBottomLeftNode = newCorners[3]\n        \n        // console.log(`new corners: topLeft: (${newTopLeftNode.row}, ${newTopLeftNode.col}) bottomRIght: (${newBottomRightNode.row}, ${newBottomRightNode.col})`)\n        console.log(`new corners V: topLeft: (${newTopLeftNode.row}, ${newTopLeftNode.col}) topRight: (${newTopRightNode.row}, ${newTopRightNode.col})`)\n        console.log(`new corners V: bottomRight: (${newBottomRightNode.row}, ${newBottomRightNode.col}) bottomLeft: (${newBottomLeftNode.row}, ${newBottomLeftNode.col})`)\n\n        //recurse on right\n        generateMazeRec(grid, newTopLeftNode, topRightNode, newBottomRightNode, bottomLeftNode, result)\n\n        //recurse on left        \n        generateMazeRec(grid, topLeftNode, newTopLeftNode, bottomLeftNode, newBottomLeftNode, result)        \n    }\n    \n}\n\nfunction bisectHorizontally(grid, topLeftNode, bottomRightNode, numRows, numCols, result){       \n    let randomRowIndex = getRandomNumberBetween(topLeftNode.row+2, bottomRightNode.row-2)    \n    let randomGap = getRandomNumberBetween(topLeftNode.col+2, bottomRightNode.col-1) //6\n    console.log(\"random row: \" + randomRowIndex)\n    console.log(\"random gap: \" + randomGap)\n\n    let newTopLeftNode = grid[randomRowIndex][topLeftNode.row]\n    let newTopRightNode = grid[randomRowIndex][bottomRightNode.col]\n    let newBottomRightNode = grid[bottomRightNode.row][bottomRightNode.col]\n    let newBottomLeftNode = grid[bottomRightNode.row][topLeftNode.row]\n\n    for(let i = topLeftNode.row; i < bottomRightNode.col; i++){\n        if(i === randomGap || grid[randomRowIndex][i].isStart === true || grid[randomRowIndex][i].isFinish === true){\n            continue\n        }\n        // if(grid[randomRowIndex][i].isWall === true){\n        //     return [newTopLeftNode, newTopRightNode, newBottomRightNode, newBottomLeftNode]\n        // }\n        grid[randomRowIndex][i].isWall = true;        \n        result.push(grid[randomRowIndex][i])\n    }\n\n    return [newTopLeftNode, newTopRightNode, newBottomRightNode, newBottomLeftNode]\n}\n\nfunction bisectVertically(grid, topLeftNode, bottomRightNode, numRows, numCols, result){    \n    let randomColIndex = getRandomNumberBetween(topLeftNode.row+2, bottomRightNode.col-1)\n    \n    let randomGap = getRandomNumberBetween(topLeftNode.row+2, bottomRightNode.row-1) //6\n    \n    console.log(randomColIndex)\n    console.log(randomGap)\n\n    for(let i = topLeftNode.row; i < bottomRightNode.row; i++){        \n        if(i === randomGap || grid[i][randomColIndex].isStart === true || grid[i][randomColIndex].isFinish){\n            continue\n        }\n        grid[i][randomColIndex].isWall = true;        \n        result.push(grid[i][randomColIndex])\n    }\n    \n    let newTopLeftNode = grid[topLeftNode.row][randomColIndex]\n    let newBottomRightNode = grid[bottomRightNode.row][bottomRightNode.col]\n    let newTopRightNode = grid[topLeftNode.row][bottomRightNode.col]\n    let newBottomLeftNode = grid[bottomRightNode.row][randomColIndex]\n    \n    return [newTopLeftNode, newTopRightNode, newBottomRightNode, newBottomLeftNode]\n    \n}\n\nfunction getRandomNumberBetween(min,max){    \n    return Math.floor(Math.random()*(max-min+1)+min);\n}\n\nfunction chooseOrientation(width, height){\n    if(width < height){\n        return 'HORIZONTAL'\n    } else if(width > height){\n        return 'VERTICAL'\n    }\n    let rand = getRandomNumberBetween(0,1)\n    if(rand === 1){\n        return 'HORIZONTAL'\n    } else {\n        return 'VERTICAL'\n    }\n}\n\nfunction createChamber(grid, result, numRows, numCols){\n    for(let i = 0; i < numCols; i++){\n        grid[0][i].isWall = true\n        result.push(grid[0][i])\n    }\n\n    for(let i = 0; i < numRows; i++){\n        grid[i][numCols-1].isWall = true;\n        result.push(grid[i][numCols-1])\n    }\n\n    for(let i = numCols-1; i > 0; i--){\n        grid[numRows-1][i].isWall = true;\n        result.push(grid[numRows-1][i])\n    }\n\n    for(let i = numRows-1; i > 0; i--){\n        grid[i][0].isWall = true\n        result.push(grid[i][0])\n    }\n}\n\n// module.exports = generateMaze;","import React, { Component } from 'react';\n\nimport './styles.css';\n\nclass Node extends Component {\n    constructor(props){\n        super(props);\n        this.state = {\n            \n        };\n    }\n\n    render() {\n        const {\n            // value, \n            row, \n            col, \n            isStart, \n            isFinish, \n            visited,\n            isWall,\n            onMouseDown,\n            onMouseEnter,\n            onMouseUp \n        } = this.props;        \n        //? assign class depending on value passed to prop using terinary operator\n        //! <true/false statement> ? <if true, this runs> : <if false, this runs> ;\n        const extraClassName = isStart \n        ? 'node-start' \n        : isFinish \n        ? 'node-finish'\n        : visited\n        ? 'node-visited'\n        : isWall\n        ? 'node-wall'\n        : \"\";\n\n        return (\n            //assigning multiple classNames to a Node\n            <div \n                className={`node ${extraClassName}`} \n                onMouseDown={() => onMouseDown(row, col)} \n                onMouseEnter={() => onMouseEnter(row, col)} \n                onMouseUp={() => onMouseUp(row, col)}>\n                    {/* {value} */}\n            </div>\n        )\n    }\n}\n\nexport default Node;\n// export const DEFAULT_NODE = {\n//     row: 0,\n//     col: 0,\n// };\n\n/*\n    onMouseDown happens when you press you're mouse button, not when you release it\n    onMouseUp happens when you release\n    onClick happens when you press and release    \n    mouseEnter happens when you hover above an element\n*/","import React, { Component } from 'react';\nimport Collapsible from 'react-collapsible';\n\nimport Node from './Node/Node';\nimport '../styles/style.css';\n\n// import {\n//     copyObjects.clone,\n//     copyObjects.copy2dArrayOfObjects,\n//     modify\n// } from '../algorithms/copyObjects';\n\nlet GraphNode = require('../dataStructures/GraphNode').default;\n\nlet bfs = require('../algorithms/bfs').default;\nlet dfs = require('../algorithms/dfs').default;\nlet aStar = require('../algorithms/aStar').default;\nlet dijkstra = require('../algorithms/dijkstra').default;\n\n\nlet generateMaze = require('../algorithms/mazeGeneration').default;\nlet copyObjects = require('../algorithms/copyObjects').default;\n\nlet DEFAULT_START_NODE_ROW = 10;\nlet DEFAULT_START_NODE_COL = 18;\nlet DEFAULT_FINISH_NODE_ROW = 10;\nlet DEFAULT_FINISH_NODE_COL = 31;\n\nconst numRows = 20;\nconst numCols = 50;\n\nlet start = true;\n\nclass PathFinder extends Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            grid: [],\n            mouseIsPressed: false,\n            clickedStart: false,\n            clickedFinish: false\n\n        };\n    }\n\n    componentDidMount() {\n        // create grid when component is first rendered\n        const grid = this.createDefaultGrid();\n        \n        this.setState({\n            grid: grid\n        });\n    }\n\n    clear(){\n        const newGrid = this.createDefaultGrid();        \n\n        this.setState({\n            grid: newGrid\n        })\n    }\n\n    stopAlgorithm(){\n        // this.setState({ state: this.state })  \n        window.location.reload(false)                      \n    }\n\n    //when mouse button is pressed\n    handleMouseDown(row, col){\n        //if the start node is clicked\n        if(row === DEFAULT_START_NODE_ROW && col === DEFAULT_START_NODE_COL){\n            console.log(\"clicked Start node\")\n\n            const newGrid = this.getNewGridWithUpdatedStartNode(this.state.grid, row, col, DEFAULT_START_NODE_ROW, DEFAULT_START_NODE_COL)        \n            this.setState({\n                grid: newGrid,\n                clickedStart: true\n            })\n            return\n        }\n\n        if(row === DEFAULT_FINISH_NODE_ROW && col === DEFAULT_FINISH_NODE_COL){\n            console.log(\"clicked End node\")\n\n            const newGrid = this.getNewGridWithUpdatedFinishNode(this.state.grid, row, col, DEFAULT_FINISH_NODE_ROW, DEFAULT_FINISH_NODE_COL)        \n            this.setState({\n                grid: newGrid,\n                clickedFinish: true\n            })\n            return\n        }\n        \n        const newGrid = this.getNewGridWithWallToggled(this.state.grid, row, col);\n        this.setState({\n            grid: newGrid,\n            mouseIsPressed: true\n        })\n        console.log(`pressed mouse button on node (${row},${col})`)\n    }\n//////////////////////////////////////////\n    //when mouse is hovering\n    handleMouseEnter(row, col){        \n        \n        //if the start button is clicked\n        // if(row === DEFAULT_START_NODE_ROW && col === DEFAULT_START_NODE_COL){\n        if(this.state.clickedStart){\n            const newGrid = this.getNewGridWithUpdatedStartNode(this.state.grid, row, col, DEFAULT_START_NODE_ROW, DEFAULT_START_NODE_COL)\n            this.setState({\n                grid: newGrid,                \n            })\n            return\n        }\n        if(this.state.clickedFinish){\n            const newGrid = this.getNewGridWithUpdatedFinishNode(this.state.grid, row, col, DEFAULT_FINISH_NODE_ROW, DEFAULT_FINISH_NODE_COL)\n            this.setState({\n                grid: newGrid,                \n            })\n            return\n        }\n        //if the mouse isnt pressed, do nothing\n        if(!this.state.mouseIsPressed){\n            // console.log(`hovering over node ${row},${col}`)\n            \n            return\n        };\n        \n        console.log(`hovering over node (${row},${col})`)\n        let newGrid = this.getNewGridWithWallToggled(this.state.grid, row, col)\n        this.setState({\n            grid: newGrid\n        })\n\n    }\n\n    //when you release mouse button\n    handleMouseUp(row, col){\n        //once you release the mouse button, set mouseIsPressed to false\n        //console.log(`release mouse button on node (${row},${col})`)\n        this.setState({\n            mouseIsPressed: false,\n            clickedStart: false,\n            clickedFinish: false\n        })\n    }\n\n    //visualizeBFS(startNode, endNode){\n    visualizeBFS(){        \n\n        const {grid} = this.state;\n\n        const startNode = grid[DEFAULT_START_NODE_ROW][DEFAULT_START_NODE_COL];\n        const finishNode = grid[DEFAULT_FINISH_NODE_ROW][DEFAULT_FINISH_NODE_COL];\n\n        const visitedNodes = bfs(grid, startNode, finishNode, numRows, numCols);\n\n        this.animate(visitedNodes);\n\n    }\n\n    visualizeDFS(){\n        const {grid} = this.state;\n\n        const startNode = grid[DEFAULT_START_NODE_ROW][DEFAULT_START_NODE_COL];\n        const finishNode = grid[DEFAULT_FINISH_NODE_ROW][DEFAULT_FINISH_NODE_COL];\n\n        let visitedNodes = dfs(grid, startNode, finishNode, numRows, numCols);        \n\n        this.animate(visitedNodes);\n    }\n\n    visualizeAStar(){\n        const {grid} = this.state;\n\n        const startNode = grid[DEFAULT_START_NODE_ROW][DEFAULT_START_NODE_COL];\n        const finishNode = grid[DEFAULT_FINISH_NODE_ROW][DEFAULT_FINISH_NODE_COL];\n\n        let visitedNodes = aStar(grid, startNode, finishNode, numRows, numCols);\n\n        this.animate(visitedNodes);\n    }\n\n    visualizeDijkstra(){\n        const {grid} = this.state;\n\n        const startNode = grid[DEFAULT_START_NODE_ROW][DEFAULT_START_NODE_COL];\n        const finishNode = grid[DEFAULT_FINISH_NODE_ROW][DEFAULT_FINISH_NODE_COL];\n\n        let visitedNodes = dijkstra(grid, startNode, finishNode, numRows, numCols);\n\n        this.animate(visitedNodes);\n\n    }\n\n    createMaze(){\n        const {grid} = this.state;\n\n        let visitedNodes = generateMaze(grid, numRows, numCols)\n\n        this.animateMaze(visitedNodes)\n    }\n\n    animate(visitedNodes){\n        for(let index in visitedNodes){\n            setTimeout(() => {\n                if(!start){\n                    return\n                }\n\n                const updatedGrid = copyObjects.copy2dArrayOfObjects(this.state.grid);\n                const currentNode = visitedNodes[index]; \n                \n                updatedGrid[currentNode.row][currentNode.col].visited = true; \n                \n                this.setState({\n                    grid: updatedGrid\n                })\n            }, 50 * index)\n        }\n    }    \n\n    animateMaze(visitedNodes){\n        for(let index in visitedNodes){\n            setTimeout(() => {\n                if(!start){\n                    return\n                }\n\n                const updatedGrid = copyObjects.copy2dArrayOfObjects(this.state.grid);\n                const currentNode = visitedNodes[index]; \n                \n                updatedGrid[currentNode.row][currentNode.col].isWall = true; \n                \n                this.setState({\n                    grid: updatedGrid\n                })\n            }, 35 * index)\n        }\n    }\n\n    render() {\n        const {grid} = this.state;  \n        \n        let count = 0;        \n\n        return (\n            <>\n            {/* <button onClick={() => this.createMaze()}>\n                Create Maze\n            </button> */}    \n            <Collapsible trigger=\"Help\" className=\"help\">\n                <p className=\"start_text\">• Green = start</p>\n                <p className=\"end_text\">• Red = finish</p>\n                <p className=\"regular_text\">• Clear = remove walls / visited nodes ( If algorithm is in mid execution, algorithm will continue running after clear )</p>\n                <p className=\"regular_text\">• Click and drag on grid to create walls</p>\n                <p className=\"regular_text\">• After running an algorithm, if you click another algorithm and it does not animate, click the 'restart' button</p>                          \n            </Collapsible>\n\n            <Collapsible trigger=\"Algorithm Guide\" className=\"algo\">\n                <Collapsible trigger=\"Breadth First Search ( BFS )\">    \n                <div className=\"regular_text\">                \n                    <p>\n                    <h1>Summary</h1>\n                    BFS is an algorithm that, starting at a root node, visits all of that root's neighbors. Neighbors are also nodes, and 'root' is just a name for the starting node. After visiting all the neighbors of\n                    the root, it visits all the neighbors of the root's neighbors. This pattern continues in a recursive fashion until eventually, the target node is a neighbor.                    \n                    </p>\n                    <p>                    \n                    This behavior, similar to dropping a rock in a pond and having the ripples expand outward, is captured programmatically through the use of a queue.\n                    </p>\n                    <p>\n                    <h1>How it Works</h1>\n                    A node (beginning with the root node) is enqueued into a queue. While the queue is not empty, the node that is next in line is dequeued from the queue, and then each of that nodes\n                    neighbors is enqueued into the queue. A check is performed to see if at any point a neighbor is the target node.\n                    </p>\n                </div>\n                    \n                </Collapsible>\n                <Collapsible trigger=\"Depth First Search ( DFS )\">\n                <div className=\"regular_text\">                \n                    <p>\n                    <h1>Summary</h1>\n                    DFS is an algorithm that, starting at a root node, picks a single neighbor. A neighbor is also a node, and 'root' is just a name for the starting node. After picking one neighbor of the root, it picks\n                    a single neighbor of the roots neighbor. The idea is to pick a single route, and to go as far down that route as possible. After reaching the end of that route, it starts at the beginning and then \n                    picks another unvisited route.\n                    </p>\n                    <p>                    \n                    Similar to driving as far down a road as possible, reversing and then going as far as you can down another road until you visit all the roads in your neighborhood\n                    , this behavior is captured programmatically through the use of recursion programming.\n                    </p>\n                    <p>\n                    <h1>How it Works</h1>\n                    Iterate through all the neighbors of a node (beginning with the root node) in a DFS function that accepts a root as a parameter. For each neighbor, call DFS again with that \n                    neighbor passed as the root. Continually check if the root is the target node.                     \n                    </p>\n                </div>\n                </Collapsible>\n                <Collapsible trigger=\"A* ( A star )\">\n                <div className=\"regular_text\">                \n                    <p>\n                        <h1>Summary</h1>\n                        A* is a pathfinding algorithm backed by simple artificial intelligence. It uses hueristics to make an educated guess at every node, and by doing this it dynamically finds the shortest path to a target node. It's quicker\n                        than Dijkstra's, but only on the condition that the location of the target node is known.\n                    </p>\n\n                    <h1>How it Works</h1>\n                    <p>\n                        <h3>Basics</h3>    \n                        Every node has 3 costs associated with it: a G cost (distance the node is from the starting node), an H cost (distance the node is from the target node) \n                        and an F cost (sum of the G and H cost). Every neighbor of the node has it's F cost calcuated via a hueristic, and whichever node has the lowest F cost is visited next. The choosing\n                        of the lowest F cost is the educated guess that the algorithm is making.\n                    </p>\n                    <p>\n                        <h3>Hueristics: Calculating the H Cost</h3>\n                        <li>\n                        Manhattan distance (what this visualizer uses)\n                        </li>\n                        <ul>\n                            <li type=\"circle\">\n                            HCost = Math.abs(target_node_row - current_node_row) + Math.abs(target_node_col - current_node_col)\n                            </li>\n                            <li type=\"circle\">\n                                This hueristic is used when a node is allowed to move in four directions (up, down, left, right)\n                            </li>  \n                        </ul>\n                        <li>\n                        Diagonal distance\n                        </li>\n                        <ul>\n                            <li type=\"circle\">\n                            H Cost = Max(Math.abs(current_node_row + target_node_row), Math.abs(current_node_col + current_node_col))\n                            </li>\n                            <li type=\"circle\">\n                                This hueristic is used when a node is allowed to move in 8 directions (up, down, left, right, all corners)\n                            </li>                   \n                        </ul>                                            \n                        <h3>Hueristics: Calculating the G Cost</h3>\n                        <li>\n                        There are differnt ways to calculate the G Cost depending on the application. Since this visualizer uses a 2-d grid, this formula is used:\n                        <ul>\n                            <li type=\"circle\">\n                            G Cost = (sqrt(Math.abs(current_node_col - start_node_col) + Math.abs(current_node_row - start_node_row)) * 10)\n                            </li>                                       \n                        </ul>\n                        </li>\n                    </p>  \n                </div>\n                </Collapsible>\n                <Collapsible trigger=\"Dijkstra\">\n                    <div className=\"regular_text\"> \n                        <p>\n                            <h1>Summary</h1>\n                            Dijkstra's is a pathfinding algorithm that finds the shortest cost to a target node. Initially it does not know where the target node is, unlike A*.\n                        </p>\n\n                        <p>\n                            <h1>How it Works</h1>\n                            The tentative cost of each node is set to infinity, escept the initial node which is set to 0. At each node, \n                            the cost of its neighbors is calculated by taking the distance of that node added to the edge cost inbetween the current node and the neighbor. \n                            This is done for each neighbor.\n                        </p>\n                        <p>\n                            The costs of the neighbor nodes are either updated/ left alone depending on the lowest calculated distance. Once all nodes have been visited, the shortest \n                            cost path can be followed.                        \n                        </p>\n                    </div> \n                </Collapsible>\n                {/*  */}\n            </Collapsible>\n            <button onClick={() => this.visualizeBFS()} className=\"button\">\n                Visualize Breadth First Search Algorithm\n            </button>            \n            <button onClick={() => this.visualizeDFS()} className=\"button\">\n                Visualize Depth First Search Algorithm\n            </button>\n            <button onClick={() => this.visualizeAStar()} className=\"button\">\n                Visualize A*\n            </button>            \n            <button onClick={() => this.visualizeDijkstra()} className=\"button\">\n                Visualize Dijkstra's\n            </button>\n            <button onClick={() => this.clear()} className=\"button\">\n                Clear\n            </button>\n            <button onClick={() => this.stopAlgorithm()} className=\"button\">\n                Restart\n            </button>\n            <div className=\"grid\">\n            {/* Map can have three parameters: value, index, array */}\n                {grid.map( (row, rowIdx) => {\n                    return (\n                        <div key={rowIdx}>\n                            {row.map((node, nodeIdx) => {                                \n                                // obtaing the current node and create a div for it\n                                const {value, row, col, isStart, isFinish, visited, isWall} = node;\n                                return (\n                                    <Node \n                                        key={count++} \n                                        value={value}\n                                        row={row}\n                                        col={col}\n                                        isStart={isStart}\n                                        isFinish={isFinish}\n                                        visited={visited}\n                                        isWall={isWall}\n                                        onMouseDown={(row, col) => this.handleMouseDown(row, col)}\n                                        onMouseEnter={(row, col) => this.handleMouseEnter(row, col)}\n                                        onMouseUp={(row, col) => this.handleMouseUp(row, col)}\n                                    />\n                                )\n                            }) }                            \n                        </div>\n                    )\n                })}                \n            </div>\n            </>\n        )\n    }\n\n    createDefaultGrid(){\n        const grid = [];\n        for (let row = 0; row < numRows; row++){\n            const currentRow = [];\n            for(let col = 0; col < numCols; col++) {                \n                const currentNode = new GraphNode(\"\", row, col);                \n                currentNode.isStart = row === DEFAULT_START_NODE_ROW && col === DEFAULT_START_NODE_COL;\n                currentNode.isFinish = row === DEFAULT_FINISH_NODE_ROW && col === DEFAULT_FINISH_NODE_COL;\n                \n                currentRow.push(currentNode);\n            }\n            grid.push(currentRow);\n            //! At this point, each index contains a graphNode\n        }\n        return grid;\n    }\n\n    getNewGridWithWallToggled(grid, row, col){\n            const newGrid = copyObjects.copy2dArrayOfObjects(grid)\n            const node = newGrid[row][col]\n            const newNode = copyObjects.clone(node)\n            newNode.isWall = true\n            newGrid[row][col] = newNode\n            return newGrid\n    }\n\n    getNewGridWithUpdatedStartNode(grid, row, col, oldRow, oldCol){\n        const newGrid = copyObjects.copy2dArrayOfObjects(grid)        \n        \n        const oldStartNode = newGrid[oldRow][oldCol]\n        const newStartNode = newGrid[row][col]\n\n        const oldStartNodeCopy = copyObjects.clone(oldStartNode)\n        const newStartNodeCopy = copyObjects.clone(newStartNode)\n\n        DEFAULT_START_NODE_ROW = row\n        DEFAULT_START_NODE_COL = col  \n\n        oldStartNodeCopy.isStart = false\n        newStartNodeCopy.isStart = true\n        \n        newGrid[oldRow][oldCol] = oldStartNodeCopy        \n        newGrid[row][col] = newStartNodeCopy\n\n        return newGrid\n    }\n    \n    getNewGridWithUpdatedFinishNode(grid, row, col, oldRow, oldCol){\n        const newGrid = copyObjects.copy2dArrayOfObjects(grid)        \n        \n        const oldFinishNode = newGrid[oldRow][oldCol]\n        const newFinishNode = newGrid[row][col]\n\n        const oldStartNodeCopy = copyObjects.clone(oldFinishNode)\n        const newStartNodeCopy = copyObjects.clone(newFinishNode)\n\n        DEFAULT_FINISH_NODE_ROW = row\n        DEFAULT_FINISH_NODE_COL = col  \n\n        oldStartNodeCopy.isFinish = false\n        newStartNodeCopy.isFinish = true\n        \n        newGrid[oldRow][oldCol] = oldStartNodeCopy        \n        newGrid[row][col] = newStartNodeCopy\n\n        return newGrid\n    }\n}\n\nexport default PathFinder;\n\n/**\n * NOTES:\n * \n * TODO: When someone clicks a node, have a pop up that gives choice of setting start and end node\n * \n * \n * \n */","import React from 'react';\n\nimport logo from '../logo.svg';\n//import '../styles/style.css';\nimport '../styles/App.css';\nimport PathFinder from './PathFinder';\n\nfunction App() {\n  return (\n    <div className=\"App\">              \n      <PathFinder />      \n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './styles/index.css';\nimport App from './components/App';\nimport * as serviceWorker from './serviceWorker';\n// import { unregister } from './registerServiceWorker';\n\n//! Here is where the App component is being called\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\n\nserviceWorker.register();\n"],"sourceRoot":""}